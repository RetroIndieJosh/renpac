import os

# TODO clean option to clear all gen.rpy files
# TODO rebuild option for current behavior (clean + build) and default to normal build
# TODO proper circular dependency checking (instead of maximum nesting)

DEPENDENCY_DEPTH_MAX = 10

priority = 0
generated = []

def check_dependency(line):
    global priority

    if not line.startswith("from ."):
        return

    dependencies = line.split("from . import ", 1)[1]
    for dependency in dependencies.split(", "):
        dependency = dependency.strip()
        # indent
        for i in range(-priority):
            print("    ", end='')
        print(f" -- checking dependency {dependency}")
        if dependency not in generated:
            priority -= 1
            write_file(dependency)
            priority += 1

def cleanup():
    gen_files = list(filter(lambda file_name: file_name.endswith(".gen.rpy"), os.listdir()))
    print(f"cleaning up {len(gen_files)} files")
    for gen_file_name in gen_files:
        os.remove(gen_file_name)

def write_file(name):
    global generated
    if name in generated:
        return

    if -priority >= DEPENDENCY_DEPTH_MAX:
        print("ERROR: maximum dependency depth reached, is there a circular dependency?")
        exit(1)

    with open(f"{name}.py") as file:
        file_data = file.read()

    # indent
    for i in range(-priority):
        print("    ", end='')
    print(f"convert {name} at priority {priority}")

    with open(f"{name}.gen.rpy", "w") as file:
        line_count = 0

        write_warning(name, file)
        for line in file_data.splitlines():
            check_dependency(line)
            file.write(f"    {line}\n")
            line_count += 1

    # indent
    for i in range(-priority):
        print("    ", end='')
    print(f" => {name}.gen.rpy ({line_count} lines)")

    generated.append(name)

def write_warning(name, file):
    file.write("# THIS FILE WAS GENERATED BY RENPAC! DO NOT MODIFY MANUALLY AS CHANGES MAY BE OVERWRITTEN\n")
    file.write(f"# To make changes, modify {name}.py and run the generator again.\n\n")
    file.write(f"init {priority} python:\n")


cleanup()

ignore_list = [ "generate.py" ]
files = list(filter(lambda file_name: file_name.endswith(".py") and file_name not in ignore_list, os.listdir()))

if(len(files) == 0):
    print("no files!")
    exit()

print(f"generating {len(files)} files")
for py_file_name in files:
    name = os.path.splitext(py_file_name)[0]
    write_file(name)
    priority += 1

print("done")
