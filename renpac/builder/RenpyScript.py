import logging

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from datetime import datetime

from renpac.base import Config
from renpac.builder import python

from renpac.base.printv import *

log = logging.getLogger("RenpyScript")

class RenpyScript:
    def __init__(self, output_path: Path, priority: int = 0, 
                source_path: Optional[str] = None, 
                indent = 4) -> None:
        self._output_path: Path = output_path
        self._priority: int = priority
        self._source_path: Optional[str] = source_path
        self._indent_str: str = ' ' * indent

        self._script_objects: List[python.Object] = []
        self._python: List[str] = []
        self._renpy: List[str] = []

    def add_header(self, header: str, python: bool = True) -> None:
        header_lines: List[str] = [
            "",
            "#######################",
            f"# {header}",
            "#######################"]
        if python:
            self.add_python(*header_lines)
        else:
            self.add_renpy(*header_lines)

    def add_object(self, script_object: python.Object) -> None:
        self.add_python(*script_object.to_python())

    def add_python(self, *args: str) -> None:
        self._python += [f"{line}\n" for line in list(args)]
    
    def add_renpy(self, *args: str) -> None:
        self._renpy += [f"{line}\n" for line in list(args)]

    def clear(self) -> None:
        self._python = []
        self._renpy = []
    
    def print(self) -> None:
        printv(self._python)
        printv(self._renpy)

    def is_empty(self) -> bool:
        return len(self._python) + len(self._renpy) == 0

    # TODO should we genericize script to be able to write any script? and put
    # the init [priority] python higher up? maybe RenpyScript(Script)
    def write(self) -> None:
        if self.is_empty():
            return
        self._output_path.parent.mkdir(exist_ok = True)
        with open(self._output_path, "w") as file:
            file.writelines([
                f"# Generated by renpac v0.0 at {datetime.now()}\n",
                "# THE FOLLOWING WAS GENERATED BY RENPAC\n",
                "# DO **NOT** MODIFY MANUALLY, AS CHANGES MAY BE OVERWRITTEN!\n"])
            if self._source_path is not None:
                file.writelines([
                    "\n# To make changes, modify:\n",
                    f"# {self._indent_str}{self._source_path}\n",
                    "# and run the generator again.\n"])
            file.writelines(self._renpy)
            file.write(f"\ninit {self._priority} python:\n")

            in_comment: bool = False
            line: str
            for line in self._python:
                stripped = line.strip()
                if len(stripped) == 0:
                    continue
                if stripped != '"""' and stripped.startswith('"""') and stripped.endswith('"""'):
                    continue
                if stripped.startswith('"""') and not in_comment:
                    in_comment = True
                    continue
                if stripped.endswith('"""') and in_comment:
                    in_comment = False
                    continue
                if stripped.startswith('#') or in_comment:
                    continue
                file.write(f"{self._indent_str}{line}")

if __name__ == "__main__":
    path: Path = Path(__file__).parent.joinpath("test.gen.rpy")

    indent_str = input("Indent? (blank for default) ")
    indent = 4 if indent_str == "" else int(indent_str)

    script = RenpyScript(path, 89, "RenpyScript test function", indent)

    script.add_header("test python header")
    script.add_header("test renpy header", False)
    script.add_python("test python line")
    script.add_renpy("test renpy line")

    foo = python.Object("foo", "Bar('foo')")
    foo.add_value("num", "4", Config.Type.INT)
    foo.add_value("float", "45.872", Config.Type.FLOAT)
    foo.add_value("coord", "82 99", Config.Type.COORD)
    foo.add_value("string", "A foobar", Config.Type.STRING)
    foo.add_value("truth", "yes", Config.Type.BOOL)
    foo.add_value("truth2", "True", Config.Type.BOOL)
    foo.add_value("truth3", "1", Config.Type.BOOL)
    foo.add_value("lies", "no", Config.Type.BOOL)
    foo.add_value("lies2", "fAlSe", Config.Type.BOOL)
    foo.add_value("lies3", "0", Config.Type.BOOL)

    foo.add_call(python.Call("print"))

    set_pos = python.Call("set_value")
    set_pos.add_arg(python.Value("394", Config.Type.INT))
    foo.add_call(set_pos)

    x = python.Value("9.88", Config.Type.FLOAT)
    y = python.Value("-18.2", Config.Type.FLOAT)
    foo.add_call(python.Call("set_pos", [x, y]))

    item_names = python.Call("add_names")
    item_names.add_arg(python.Value("chicken"))
    item_names.add_arg(python.Value("steak"))
    item_names.add_arg(python.Value("tuna"))
    item_names.add_arg(python.Value("banana"))
    item_names.add_arg(python.Value("broccoli"))
    foo.add_call(item_names)

    items = python.Call("add_items")
    items.add_arg(python.Value("chicken", Config.Type.LITERAL))
    items.add_arg(python.Value("steak", Config.Type.LITERAL))
    items.add_arg(python.Value("tuna", Config.Type.LITERAL))
    items.add_arg(python.Value("banana", Config.Type.LITERAL))
    items.add_arg(python.Value("broccoli", Config.Type.LITERAL))
    foo.add_call(items)

    script.add_object(foo)

    script.write()

    EXPECTED_LINES = 23
    line_count = len(path.read_text().splitlines())
    if line_count == EXPECTED_LINES:
        print(f"Line count matches.")
    else:
        print(f"Something went wrong. Expected {EXPECTED_LINES} lines but wrote {line_count}.")

    print("** FILE BEGIN **")
    print(path.read_text())
    print("** FILE END **")
    path.unlink()